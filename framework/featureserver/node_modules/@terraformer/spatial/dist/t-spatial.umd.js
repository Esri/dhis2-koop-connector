/* @preserve
* @terraformer/spatial - v2.1.1 - MIT
* Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.
* Tue Aug 02 2022 14:23:46 GMT-0700 (Pacific Daylight Time)
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Terraformer = global.Terraformer || {}));
})(this, (function (exports) { 'use strict';

  /*
  Internal: Calculate an bounding box from an nested array of positions
  [
    [
      [ [lng, lat],[lng, lat],[lng, lat] ]
    ]
    [
      [lng, lat],[lng, lat],[lng, lat]
    ]
    [
      [lng, lat],[lng, lat],[lng, lat]
    ]
  ]
  */
  var calculateBoundsFromNestedArrays = function calculateBoundsFromNestedArrays(array) {
    var x1 = null;
    var x2 = null;
    var y1 = null;
    var y2 = null;

    for (var i = 0; i < array.length; i++) {
      var inner = array[i];

      for (var j = 0; j < inner.length; j++) {
        var lonlat = inner[j];
        var lon = lonlat[0];
        var lat = lonlat[1];

        if (x1 === null) {
          x1 = lon;
        } else if (lon < x1) {
          x1 = lon;
        }

        if (x2 === null) {
          x2 = lon;
        } else if (lon > x2) {
          x2 = lon;
        }

        if (y1 === null) {
          y1 = lat;
        } else if (lat < y1) {
          y1 = lat;
        }

        if (y2 === null) {
          y2 = lat;
        } else if (lat > y2) {
          y2 = lat;
        }
      }
    }

    return [x1, y1, x2, y2];
  };
  /*
  Internal: Calculate a bounding box from an array of arrays of arrays
  [
    [ [lng, lat],[lng, lat],[lng, lat] ]
    [ [lng, lat],[lng, lat],[lng, lat] ]
    [ [lng, lat],[lng, lat],[lng, lat] ]
  ]
  */


  var calculateBoundsFromNestedArrayOfArrays = function calculateBoundsFromNestedArrayOfArrays(array) {
    var x1 = null;
    var x2 = null;
    var y1 = null;
    var y2 = null;

    for (var i = 0; i < array.length; i++) {
      var inner = array[i]; // return calculateBoundsFromNestedArrays(inner); // more DRY?

      for (var j = 0; j < inner.length; j++) {
        var innerinner = inner[j];

        for (var k = 0; k < innerinner.length; k++) {
          var lonlat = innerinner[k];
          var lon = lonlat[0];
          var lat = lonlat[1];

          if (x1 === null) {
            x1 = lon;
          } else if (lon < x1) {
            x1 = lon;
          }

          if (x2 === null) {
            x2 = lon;
          } else if (lon > x2) {
            x2 = lon;
          }

          if (y1 === null) {
            y1 = lat;
          } else if (lat < y1) {
            y1 = lat;
          }

          if (y2 === null) {
            y2 = lat;
          } else if (lat > y2) {
            y2 = lat;
          }
        }
      }
    }

    return [x1, y1, x2, y2];
  };
  /*
  Internal: Calculate a bounding box from an array of positions
  [
    [lng, lat],[lng, lat],[lng, lat]
  ]
  */


  var calculateBoundsFromArray = function calculateBoundsFromArray(array) {
    var x1 = null;
    var x2 = null;
    var y1 = null;
    var y2 = null;

    for (var i = 0; i < array.length; i++) {
      var lonlat = array[i];
      var lon = lonlat[0];
      var lat = lonlat[1];

      if (x1 === null) {
        x1 = lon;
      } else if (lon < x1) {
        x1 = lon;
      }

      if (x2 === null) {
        x2 = lon;
      } else if (lon > x2) {
        x2 = lon;
      }

      if (y1 === null) {
        y1 = lat;
      } else if (lat < y1) {
        y1 = lat;
      }

      if (y2 === null) {
        y2 = lat;
      } else if (lat > y2) {
        y2 = lat;
      }
    }

    return [x1, y1, x2, y2];
  };
  /*
  Internal: Calculate an bounding box for a feature collection
  */


  var calculateBoundsForFeatureCollection = function calculateBoundsForFeatureCollection(featureCollection) {
    var extents = [];

    for (var i = featureCollection.features.length - 1; i >= 0; i--) {
      var extent = calculateBounds(featureCollection.features[i].geometry);
      extents.push([extent[0], extent[1]]);
      extents.push([extent[2], extent[3]]);
    }

    return calculateBoundsFromArray(extents);
  };
  /*
  Internal: Calculate an bounding box for a geometry collection
  */


  var calculateBoundsForGeometryCollection = function calculateBoundsForGeometryCollection(geometryCollection) {
    var extents = [];

    for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {
      var extent = calculateBounds(geometryCollection.geometries[i]);
      extents.push([extent[0], extent[1]]);
      extents.push([extent[2], extent[3]]);
    }

    return calculateBoundsFromArray(extents);
  };

  var calculateBounds = function calculateBounds(geojson) {
    if (geojson.type) {
      switch (geojson.type) {
        case 'Point':
          return [geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];

        case 'MultiPoint':
          return calculateBoundsFromArray(geojson.coordinates);

        case 'LineString':
          return calculateBoundsFromArray(geojson.coordinates);

        case 'MultiLineString':
          return calculateBoundsFromNestedArrays(geojson.coordinates);

        case 'Polygon':
          return calculateBoundsFromNestedArrays(geojson.coordinates);

        case 'MultiPolygon':
          return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);

        case 'Feature':
          return geojson.geometry ? calculateBounds(geojson.geometry) : null;

        case 'FeatureCollection':
          return calculateBoundsForFeatureCollection(geojson);

        case 'GeometryCollection':
          return calculateBoundsForGeometryCollection(geojson);

        default:
          throw new Error('Unknown type: ' + geojson.type);
      }
    }

    return null;
  };

  var EARTH_RADIUS = 6378137;
  var DEGREES_PER_RADIAN = 57.295779513082320;
  var RADIANS_PER_DEGREE = 0.017453292519943;
  var MercatorCRS = {
    type: 'link',
    properties: {
      href: 'http://spatialreference.org/ref/sr-org/6928/ogcwkt/',
      type: 'ogcwkt'
    }
  };
  var GeographicCRS = {
    type: 'link',
    properties: {
      href: 'http://spatialreference.org/ref/epsg/4326/ogcwkt/',
      type: 'ogcwkt'
    }
  };

  /*
  Internal: Convert radians to degrees. Used by spatial reference converters.
  */

  var radToDeg = function radToDeg(rad) {
    return rad * DEGREES_PER_RADIAN;
  };
  /*
  Internal: Convert degrees to radians. Used by spatial reference converters.
  */

  var degToRad = function degToRad(deg) {
    return deg * RADIANS_PER_DEGREE;
  };
  var positionToGeographic = function positionToGeographic(position) {
    var x = position[0];
    var y = position[1];
    return [radToDeg(x / EARTH_RADIUS) - Math.floor((radToDeg(x / EARTH_RADIUS) + 180) / 360) * 360, radToDeg(Math.PI / 2 - 2 * Math.atan(Math.exp(-1.0 * y / EARTH_RADIUS)))];
  };
  var positionToMercator = function positionToMercator(position) {
    var lng = position[0];
    var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);
    return [degToRad(lng) * EARTH_RADIUS, EARTH_RADIUS / 2.0 * Math.log((1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))))];
  };

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */
  var isNumber = function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  var edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {
    var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
    var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
    var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

    if (uB !== 0) {
      var ua = uaT / uB;
      var ub = ubT / uB;

      if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return true;
      }
    }

    return false;
  };

  var arraysIntersectArrays = function arraysIntersectArrays(a, b) {
    if (isNumber(a[0][0])) {
      if (isNumber(b[0][0])) {
        for (var i = 0; i < a.length - 1; i++) {
          for (var j = 0; j < b.length - 1; j++) {
            if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
              return true;
            }
          }
        }
      } else {
        for (var k = 0; k < b.length; k++) {
          if (arraysIntersectArrays(a, b[k])) {
            return true;
          }
        }
      }
    } else {
      for (var l = 0; l < a.length; l++) {
        if (arraysIntersectArrays(a[l], b)) {
          return true;
        }
      }
    }

    return false;
  };
  var coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {
    var contains = false;

    for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
      if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
        contains = !contains;
      }
    }

    return contains;
  };
  var pointsEqual = function pointsEqual(a, b) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  };

  /*
  Internal: used for sorting
  */

  var compSort = function compSort(p1, p2) {
    if (p1[0] > p2[0]) {
      return -1;
    } else if (p1[0] < p2[0]) {
      return 1;
    } else if (p1[1] > p2[1]) {
      return -1;
    } else if (p1[1] < p2[1]) {
      return 1;
    } else {
      return 0;
    }
  };
  /*
    Internal: -1,0,1 comparison function
    */

  var cmp = function cmp(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  /*
    Internal: used to determine turn
    */


  var turn = function turn(p, q, r) {
    // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.
    return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);
  };
  /*
    Internal: used to determine euclidean distance between two points
    */


  var euclideanDistance = function euclideanDistance(p, q) {
    // Returns the squared Euclidean distance between p and q.
    var dx = q[0] - p[0];
    var dy = q[1] - p[1];
    return dx * dx + dy * dy;
  };

  var nextHullPoint = function nextHullPoint(points, p) {
    // Returns the next point on the convex hull in CCW from p.
    var q = p;

    for (var r in points) {
      var t = turn(p, q, points[r]);

      if (t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {
        q = points[r];
      }
    }

    return q;
  };

  var coordinateConvexHull = function coordinateConvexHull(points) {
    // implementation of the Jarvis March algorithm
    // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/
    if (points.length === 0) {
      return [];
    } else if (points.length === 1) {
      return points;
    } // Returns the points on the convex hull of points in CCW order.


    var hull = [points.sort(compSort)[0]];

    for (var p = 0; p < hull.length; p++) {
      var q = nextHullPoint(points, hull[p]);

      if (q !== hull[0]) {
        hull.push(q);
      }
    }

    return hull;
  };
  /*
  Internal: Returns a copy of coordinates for a closed polygon
  */

  var closedPolygon = function closedPolygon(coordinates) {
    var outer = [];

    for (var i = 0; i < coordinates.length; i++) {
      var inner = coordinates[i].slice();

      if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {
        inner.push(inner[0]);
      }

      outer.push(inner);
    }

    return outer;
  };
  /*
  Internal: safe warning
  */

  function warn() {
    var args = Array.prototype.slice.apply(arguments);

    if (typeof console !== 'undefined' && console.warn) {
      console.warn.apply(console, args);
    }
  }
  /*
  Internal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.
  */

  var eachPosition = function eachPosition(coordinates, func) {
    for (var i = 0; i < coordinates.length; i++) {
      // we found a number so lets convert the pair
      if (typeof coordinates[i][0] === 'number') {
        coordinates[i] = func(coordinates[i]);
      } // we found an coordinates array it again and run the function against it


      if (_typeof(coordinates[i]) === 'object') {
        coordinates[i] = eachPosition(coordinates[i], func);
      }
    }

    return coordinates;
  };
  /*
  Apply a function agaist all positions in a geojson object. Used by spatial reference converters.
  */


  var applyConverter = function applyConverter(geojson, converter, noCrs) {
    if (geojson.type === 'Point') {
      geojson.coordinates = converter(geojson.coordinates);
    } else if (geojson.type === 'Feature') {
      geojson.geometry = applyConverter(geojson.geometry, converter, true);
    } else if (geojson.type === 'FeatureCollection') {
      for (var f = 0; f < geojson.features.length; f++) {
        geojson.features[f] = applyConverter(geojson.features[f], converter, true);
      }
    } else if (geojson.type === 'GeometryCollection') {
      for (var g = 0; g < geojson.geometries.length; g++) {
        geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);
      }
    } else {
      geojson.coordinates = eachPosition(geojson.coordinates, converter);
    }

    if (!noCrs) {
      if (converter === positionToMercator) {
        geojson.crs = MercatorCRS;
      }
    }

    if (converter === positionToGeographic) {
      delete geojson.crs;
    }

    return geojson;
  };
  var coordinatesEqual = function coordinatesEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    var na = a.slice().sort(compSort);
    var nb = b.slice().sort(compSort);

    for (var i = 0; i < na.length; i++) {
      if (na[i].length !== nb[i].length) {
        return false;
      }

      for (var j = 0; j < na.length; j++) {
        if (na[i][j] !== nb[i][j]) {
          return false;
        }
      }
    }

    return true;
  };

  var convexHull = function convexHull(geojson) {
    var coordinates = [];
    var i;
    var j;

    if (geojson.type === 'Point') {
      return null;
    } else if (geojson.type === 'LineString' || geojson.type === 'MultiPoint') {
      if (geojson.coordinates && geojson.coordinates.length >= 3) {
        coordinates = geojson.coordinates;
      } else {
        return null;
      }
    } else if (geojson.type === 'Polygon' || geojson.type === 'MultiLineString') {
      if (geojson.coordinates && geojson.coordinates.length > 0) {
        for (i = 0; i < geojson.coordinates.length; i++) {
          coordinates = coordinates.concat(geojson.coordinates[i]);
        }

        if (coordinates.length < 3) {
          return null;
        }
      } else {
        return null;
      }
    } else if (geojson.type === 'MultiPolygon') {
      if (geojson.coordinates && geojson.coordinates.length > 0) {
        for (i = 0; i < geojson.coordinates.length; i++) {
          for (j = 0; j < geojson.coordinates[i].length; j++) {
            coordinates = coordinates.concat(geojson.coordinates[i][j]);
          }
        }

        if (coordinates.length < 3) {
          return null;
        }
      } else {
        return null;
      }
    } else if (geojson.type === 'Feature') {
      return convexHull(geojson.geometry);
    }

    return {
      type: 'Polygon',
      coordinates: closedPolygon([coordinateConvexHull(coordinates)])
    };
  };
  var isConvex = function isConvex(points) {
    var ltz;

    for (var i = 0; i < points.length - 3; i++) {
      var p1 = points[i];
      var p2 = points[i + 1];
      var p3 = points[i + 2];
      var v = [p2[0] - p1[0], p2[1] - p1[1]]; // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x

      var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];

      if (i === 0) {
        if (res < 0) {
          ltz = true;
        } else {
          ltz = false;
        }
      } else {
        if (ltz && res > 0 || !ltz && res < 0) {
          return false;
        }
      }
    }

    return true;
  };

  var polygonContainsPoint = function polygonContainsPoint(polygon, point) {
    if (polygon && polygon.length) {
      if (polygon.length === 1) {
        // polygon with no holes
        return coordinatesContainPoint(polygon[0], point);
      } else {
        // polygon with holes
        if (coordinatesContainPoint(polygon[0], point)) {
          for (var i = 1; i < polygon.length; i++) {
            if (coordinatesContainPoint(polygon[i], point)) {
              return false; // found in hole
            }
          }

          return true;
        } else {
          return false;
        }
      }
    } else {
      return false;
    }
  };

  var within = function within(geoJSON, comparisonGeoJSON) {
    var coordinates, i, contains; // if we are passed a feature, use the polygon inside instead

    if (comparisonGeoJSON.type === 'Feature') {
      comparisonGeoJSON = comparisonGeoJSON.geometry;
    } // point.within(point) :: equality


    if (comparisonGeoJSON.type === 'Point') {
      if (geoJSON.type === 'Point') {
        return pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates);
      }
    } // point.within(multilinestring)


    if (comparisonGeoJSON.type === 'MultiLineString') {
      if (geoJSON.type === 'Point') {
        for (i = 0; i < geoJSON.coordinates.length; i++) {
          var linestring = {
            type: 'LineString',
            coordinates: comparisonGeoJSON.coordinates[i]
          };

          if (within(geoJSON, linestring)) {
            return true;
          }
        }
      }
    } // point.within(linestring), point.within(multipoint)


    if (comparisonGeoJSON.type === 'LineString' || comparisonGeoJSON.type === 'MultiPoint') {
      if (geoJSON.type === 'Point') {
        for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {
          if (geoJSON.coordinates.length !== comparisonGeoJSON.coordinates[i].length) {
            return false;
          }

          if (pointsEqual(geoJSON.coordinates, comparisonGeoJSON.coordinates[i])) {
            return true;
          }
        }
      }
    }

    if (comparisonGeoJSON.type === 'Polygon') {
      // polygon.within(polygon)
      if (geoJSON.type === 'Polygon') {
        // check for equal polygons
        if (comparisonGeoJSON.coordinates.length === geoJSON.coordinates.length) {
          for (i = 0; i < geoJSON.coordinates.length; i++) {
            if (coordinatesEqual(geoJSON.coordinates[i], comparisonGeoJSON.coordinates[i])) {
              return true;
            }
          }
        }

        if (geoJSON.coordinates.length && polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[0][0])) {
          return !arraysIntersectArrays(closedPolygon(geoJSON.coordinates), closedPolygon(comparisonGeoJSON.coordinates));
        } else {
          return false;
        } // point.within(polygon)

      } else if (geoJSON.type === 'Point') {
        return polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates); // linestring/multipoint withing polygon
      } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {
        if (!geoJSON.coordinates || geoJSON.coordinates.length === 0) {
          return false;
        }

        for (i = 0; i < geoJSON.coordinates.length; i++) {
          if (polygonContainsPoint(comparisonGeoJSON.coordinates, geoJSON.coordinates[i]) === false) {
            return false;
          }
        }

        return true; // multilinestring.within(polygon)
      } else if (geoJSON.type === 'MultiLineString') {
        for (i = 0; i < geoJSON.coordinates.length; i++) {
          var ls = {
            type: 'LineString',
            coordinates: geoJSON.coordinates[i]
          };

          if (within(ls, comparisonGeoJSON) === false) {
            contains++;
            return false;
          }
        }

        return true; // multipolygon.within(polygon)
      } else if (geoJSON.type === 'MultiPolygon') {
        for (i = 0; i < geoJSON.coordinates.length; i++) {
          var p1 = {
            type: 'Polygon',
            coordinates: geoJSON.coordinates[i]
          };

          if (within(p1, comparisonGeoJSON) === false) {
            return false;
          }
        }

        return true;
      }
    }

    if (comparisonGeoJSON.type === 'MultiPolygon') {
      // point.within(multipolygon)
      if (geoJSON.type === 'Point') {
        if (comparisonGeoJSON.coordinates.length) {
          for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {
            coordinates = comparisonGeoJSON.coordinates[i];

            if (polygonContainsPoint(coordinates, geoJSON.coordinates) && arraysIntersectArrays([geoJSON.coordinates], comparisonGeoJSON.coordinates) === false) {
              return true;
            }
          }
        }

        return false; // polygon.within(multipolygon)
      } else if (geoJSON.type === 'Polygon') {
        for (i = 0; i < geoJSON.coordinates.length; i++) {
          if (comparisonGeoJSON.coordinates[i].length === geoJSON.coordinates.length) {
            for (var j = 0; j < geoJSON.coordinates.length; j++) {
              if (coordinatesEqual(geoJSON.coordinates[j], comparisonGeoJSON.coordinates[i][j])) {
                return true;
              }
            }
          }
        }

        if (arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates) === false) {
          if (comparisonGeoJSON.coordinates.length) {
            for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {
              coordinates = comparisonGeoJSON.coordinates[i];

              if (polygonContainsPoint(coordinates, geoJSON.coordinates[0][0]) === false) {
                contains = false;
              } else {
                contains = true;
              }
            }

            return contains;
          }
        } // linestring.within(multipolygon), multipoint.within(multipolygon)

      } else if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiPoint') {
        for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {
          var poly = {
            type: 'Polygon',
            coordinates: comparisonGeoJSON.coordinates[i]
          };

          if (within(geoJSON, poly)) {
            return true;
          }

          return false;
        } // multilinestring.within(multipolygon)

      } else if (geoJSON.type === 'MultiLineString') {
        for (i = 0; i < geoJSON.coordinates.length; i++) {
          var _ls = {
            type: 'LineString',
            coordinates: geoJSON.coordinates[i]
          };

          if (within(_ls, comparisonGeoJSON) === false) {
            return false;
          }
        }

        return true; // multipolygon.within(multipolygon)
      } else if (geoJSON.type === 'MultiPolygon') {
        for (i = 0; i < comparisonGeoJSON.coordinates.length; i++) {
          var mpoly = {
            type: 'Polygon',
            coordinates: comparisonGeoJSON.coordinates[i]
          };

          if (within(geoJSON, mpoly) === false) {
            return false;
          }
        }

        return true;
      }
    } // default to false


    return false;
  };

  var contains = function contains(geoJSON, comparisonGeoJSON) {
    return within(comparisonGeoJSON, geoJSON);
  };

  var intersects = function intersects(geoJSON, comparisonGeoJSON) {
    // if we are passed a feature, use the polygon inside instead
    if (comparisonGeoJSON.type === 'Feature') {
      comparisonGeoJSON = comparisonGeoJSON.geometry;
    }

    if (within(geoJSON, comparisonGeoJSON) || within(comparisonGeoJSON, geoJSON)) {
      return true;
    }

    if (geoJSON.type === 'MultiPolygon' && multipolygonIntersection(geoJSON, comparisonGeoJSON)) {
      return true;
    }

    if (geoJSON.type !== 'Point' && geoJSON.type !== 'MultiPoint' && comparisonGeoJSON.type !== 'Point' && comparisonGeoJSON.type !== 'MultiPoint') {
      return arraysIntersectArrays(geoJSON.coordinates, comparisonGeoJSON.coordinates);
    } else if (geoJSON.type === 'Feature') {
      // in the case of a Feature, use the internal geometry for intersection
      var inner = geoJSON.geometry;
      return intersects(inner, comparisonGeoJSON);
    }

    warn('Type ' + geoJSON.type + ' to ' + comparisonGeoJSON.type + ' intersection is not supported by intersects');
    return false;
  };

  function multipolygonIntersection(geoJSON, comparisonGeoJSON) {
    return geoJSON.coordinates.some(function (coordinates) {
      var componentPolygon = {
        type: 'Polygon',
        coordinates: coordinates
      };
      return within(componentPolygon, comparisonGeoJSON) || within(comparisonGeoJSON, componentPolygon);
    });
  }

  var VINCENTY = {
    a: 6378137,
    b: 6356752.3142,
    f: 1 / 298.257223563
  };
  var toGeographic = function toGeographic(geojson) {
    return applyConverter(geojson, positionToGeographic);
  };
  var toCircle = function toCircle(center, radius, interpolate) {
    var steps = interpolate || 64;
    var rad = radius || 250;

    if (!center || center.length < 2 || !rad || !steps) {
      throw new Error('Terraformer: missing parameter for Terraformer.Circle');
    }

    return {
      type: 'Feature',
      geometry: createGeodesicCircle(center, rad, steps),
      properties: {
        radius: rad,
        center: center,
        steps: steps
      }
    };
  };
  /* cribbed from
    http://stackoverflow.com/questions/24145205/writing-a-function-to-convert-a-circle-to-a-polygon-using-leaflet-js
  */

  var createGeodesicCircle = function createGeodesicCircle(center, radius, interpolate) {
    var steps = interpolate || 64;
    var polygon = {
      type: 'Polygon',
      coordinates: [[]]
    };
    var angle;

    for (var i = 0; i < steps; i++) {
      angle = i * 360 / steps;
      polygon.coordinates[0].push(destinationVincenty(center, angle, radius));
    }

    polygon.coordinates = closedPolygon(polygon.coordinates);
    return polygon;
  };

  var destinationVincenty = function destinationVincenty(coords, brng, dist) {
    var cos2SigmaM, sinSigma, cosSigma, deltaSigma;
    var a = VINCENTY.a;
    var b = VINCENTY.b;
    var f = VINCENTY.f;
    var lon1 = coords[0];
    var lat1 = coords[1];
    var s = dist;
    var pi = Math.PI;
    var alpha1 = brng * pi / 180; // converts brng degrees to radius

    var sinAlpha1 = Math.sin(alpha1);
    var cosAlpha1 = Math.cos(alpha1);
    var tanU1 = (1 - f) * Math.tan(lat1 * pi / 180
    /* converts lat1 degrees to radius */
    );
    var cosU1 = 1 / Math.sqrt(1 + tanU1 * tanU1);
    var sinU1 = tanU1 * cosU1;
    var sigma1 = Math.atan2(tanU1, cosAlpha1);
    var sinAlpha = cosU1 * sinAlpha1;
    var cosSqAlpha = 1 - sinAlpha * sinAlpha;
    var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
    var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
    var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
    var sigma = s / (b * A);
    var sigmaP = 2 * Math.PI;

    while (Math.abs(sigma - sigmaP) > 1e-12) {
      cos2SigmaM = Math.cos(2 * sigma1 + sigma);
      sinSigma = Math.sin(sigma);
      cosSigma = Math.cos(sigma);
      deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
      sigmaP = sigma;
      sigma = s / (b * A) + deltaSigma;
    }

    var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
    var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));
    var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);
    var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
    var lam = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
    var lamFunc = lon1 + lam * 180 / pi; // converts lam radius to degrees

    var lat2a = lat2 * 180 / pi; // converts lat2a radius to degrees

    return [lamFunc, lat2a];
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */
  /**
   * Calculate the envelope surrounding the input.
   * @function
   * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.
   * @return {Object} Object in the form { x, y, w, h }.
   * ```js
   * import { calculateEnvelope } from "@terraformer/spatial"
   *
   * calculateEnvelope({
   *   type: "Point",
   *   coordinates: [ 100, 100 ]
   * })
   *
   * >> { x: 100, y: 100, w: 0, h: 0, }
   * ```
   */

  var calculateEnvelope = function calculateEnvelope(geojson) {
    var bounds = calculateBounds(geojson);
    return {
      x: bounds[0],
      y: bounds[1],
      w: Math.abs(bounds[0] - bounds[2]),
      h: Math.abs(bounds[1] - bounds[3])
    };
  };
  /**
   * Reproject WGS84 (Lat/Lng) GeoJSON to Web Mercator.
   * @function
   * @param {object} GeoJSON - The input [GeoJSON](https://tools.ietf.org/html/rfc7946) Geometry, Feature, GeometryCollection or FeatureCollection.
   * @return {object} GeoJSON
   * ```js
   * import { toMercator } from "@terraformer/spatial"
   *
   * toMercator({
   *   type: "Point",
   *   coordinates: [ 45, 60 ]
   * })
   *
   * >> { type: "Point", coordinates: [ -13580978, 5621521 ], crs }
   * ```
   */

  var toMercator = function toMercator(geojson) {
    return applyConverter(geojson, positionToMercator);
  };

  exports.GeographicCRS = GeographicCRS;
  exports.MercatorCRS = MercatorCRS;
  exports.applyConverter = applyConverter;
  exports.calculateBounds = calculateBounds;
  exports.calculateEnvelope = calculateEnvelope;
  exports.contains = contains;
  exports.convexHull = convexHull;
  exports.intersects = intersects;
  exports.isConvex = isConvex;
  exports.polygonContainsPoint = polygonContainsPoint;
  exports.positionToGeographic = positionToGeographic;
  exports.positionToMercator = positionToMercator;
  exports.toCircle = toCircle;
  exports.toGeographic = toGeographic;
  exports.toMercator = toMercator;
  exports.within = within;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
